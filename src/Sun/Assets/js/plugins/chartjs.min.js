/*!
 * Chart.js v3.0.2
 * https://www.chartjs.org
 * (c) 2021 Chart.js Contributors
 * Released under the MIT License
 */
// !function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).Chart=e()}(this,(function(){"use strict";const t="undefined"==typeof window?function(t){return t()}:window.requestAnimationFrame;function e(e,i,n){const o=n||(t=>Array.prototype.slice.call(t));let s=!1,a=[];return function(...n){a=o(n),s||(s=!0,t.call(window,(()=>{s=!1,e.apply(i,a)})))}}function i(t,e){let i;return function(){return e?(clearTimeout(i),i=setTimeout(t,e)):t(),e}}const n=t=>"start"===t?"left":"end"===t?"right":"center",o=(t,e,i)=>"start"===t?e:"end"===t?i:(e+i)/2,s=(t,e,i)=>"right"===t?i:"center"===t?(e+i)/2:e;var a=new class{constructor(){this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}_notify(t,e,i,n){const o=e.listeners[n],s=e.duration;o.forEach((n=>n({chart:t,numSteps:s,currentStep:Math.min(i-e.start,s)})))}_refresh(){const e=this;e._request||(e._running=!0,e._request=t.call(window,(()=>{e._update(),e._request=null,e._running&&e._refresh()})))}_update(t=Date.now()){const e=this;let i=0;e._charts.forEach(((n,o)=>{if(!n.running||!n.items.length)return;const s=n.items;let a,r=s.length-1,l=!1;for(;r>=0;--r)a=s[r],a._active?(a._total>n.duration&&(n.duration=a._total),a.tick(t),l=!0):(s[r]=s[s.length-1],s.pop());l&&(o.draw(),e._notify(o,n,t,"progress")),s.length||(n.running=!1,e._notify(o,n,t,"complete")),i+=s.length})),e._lastDate=t,0===i&&(e._running=!1)}_getAnims(t){const e=this._charts;let i=e.get(t);return i||(i={running:!1,items:[],listeners:{complete:[],progress:[]}},e.set(t,i)),i}listen(t,e,i){this._getAnims(t).listeners[e].push(i)}add(t,e){e&&e.length&&this._getAnims(t).items.push(...e)}has(t){return this._getAnims(t).items.length>0}start(t){const e=this._charts.get(t);e&&(e.running=!0,e.start=Date.now(),e.duration=e.items.reduce(((t,e)=>Math.max(t,e._duration)),0),this._refresh())}running(t){if(!this._running)return!1;const e=this._charts.get(t);return!!(e&&e.running&&e.items.length)}stop(t){const e=this._charts.get(t);if(!e||!e.items.length)return;const i=e.items;let n=i.length-1;for(;n>=0;--n)i[n].cancel();e.items=[],this._notify(t,e,Date.now(),"complete")}remove(t){return this._charts.delete(t)}};
/*!
 * @kurkle/color v0.1.9
 * https://github.com/kurkle/color#readme
 * (c) 2020 Jukka Kurkela
 * Released under the MIT License
*/
import React from 'react';

class ChartComponent extends React.Component {
  constructor(props) {
    super(props);
    this.chartRef = React.createRef();
  }

  componentDidMount() {
    const chartElement = this.chartRef.current;

    const t = typeof window === 'undefined' ? (fn) => fn() : window.requestAnimationFrame;

    function e(callback, context, args) {
      const slice = args || (t => Array.prototype.slice.call(t));
      let running = false;
      let queue = [];

      return function (...args) {
        queue = slice(args);
        if (!running) {
          running = true;
          t.call(window, () => {
            running = false;
            callback.apply(context, queue);
          });
        }
      };
    }

    const n = (t) => (t === 'start' ? 'left' : t === 'end' ? 'right' : 'center');
    const o = (t, e, i) => (t === 'start' ? e : t === 'end' ? i : (e + i) / 2);
    const s = (t, e, i) => (t === 'right' ? i : t === 'center' ? (e + i) / 2 : e);

    class Chart {
      constructor() {
        this._request = null;
        this._charts = new Map();
        this._running = false;
        this._lastDate = undefined;
      }

      _notify(chart, anim, timestamp, event) {
        const listeners = anim.listeners[event];
        const duration = anim.duration;

        listeners.forEach((listener) => {
          listener({
            chart: chart,
            numSteps: duration,
            currentStep: Math.min(timestamp - anim.start, duration),
          });
        });
      }

      _refresh() {
        const self = this;
        if (!self._request) {
          self._running = true;
          self._request = t.call(window, () => {
            self._update();
            self._request = null;
            if (self._running) {
              self._refresh();
            }
          });
        }
      }

      _update(timestamp = Date.now()) {
        const self = this;
        let animatingChartsCount = 0;

        self._charts.forEach((anim, chart) => {
          if (!anim.running || !anim.items.length) return;

          const items = anim.items;
          let i = items.length - 1;
          let chartNeedsUpdate = false;

          for (; i >= 0; --i) {
            const item = items[i];
            if (item._active) {
              if (item._total > anim.duration) {
                anim.duration = item._total;
              }
              item.tick(timestamp);
              chartNeedsUpdate = true;
            } else {
              items[i] = items[items.length - 1];
              items.pop();
            }
          }

          if (chartNeedsUpdate) {
            chart.draw();
            self._notify(chart, anim, timestamp, 'progress');
          }

          if (!items.length) {
            anim.running = false;
            self._notify(chart, anim, timestamp, 'complete');
          }

          animatingChartsCount += items.length;
        });

        self._lastDate = timestamp;
        if (animatingChartsCount === 0) {
          self._running = false;
        }
      }

      _getAnims(chart) {
        const charts = this._charts;
        let anim = charts.get(chart);

        if (!anim) {
          anim = {
            running: false,
            items: [],
            listeners: {
              complete: [],
              progress: [],
            },
          };
          charts.set(chart, anim);
        }

        return anim;
      }

      listen(chart, event, callback) {
        this._getAnims(chart).listeners[event].push(callback);
      }

      add(chart, items) {
        if (items && items.length) {
          this._getAnims(chart).items.push(...items);
        }
      }

      has(chart) {
        return this._getAnims(chart).items.length > 0;
      }

      start(chart) {
        const anim = this._charts.get(chart);
        if (anim) {
          anim.running = true;
          anim.start = Date.now();
          anim.duration = anim.items.reduce((duration, item) => Math.max(duration, item._duration), 0);
          this._refresh();
        }
      }

      running(chart) {
        if (!this._running) return false;
        const anim = this._charts.get(chart);
        return !!(anim && anim.running && anim.items.length);
      }

      stop(chart) {
        const anim = this._charts.get(chart);
        if (anim && anim.items.length) {
          const items = anim.items;
          let i = items.length - 1;
          for (; i >= 0; --i) {
            items[i].cancel();
          }
          anim.items = [];
          this._notify(chart, anim, Date.now(), 'complete');
        }
      }

      remove(chart) {
        return this._charts.delete(chart);
      }
    }

    const chartInstance = new Chart();

    // Use chartInstance to interact with the charting library

    // Example usage:
    chartInstance.add('myChart', []); // Add items to the 'myChart' chart
    chartInstance.start('myChart'); // Start the animation for the 'myChart' chart

    // Rest of the code...

    // Update or create the chart using the chartRef
  }

  render() {
    return <div ref={this.chartRef} />;
  }
}

export default ChartComponent;
